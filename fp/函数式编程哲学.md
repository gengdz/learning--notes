# 函数式编程哲学

## 纯函数

定义：

> 1. 相同的输入必定产生相同的输出；
> 2. 在计算的过程中，不会产生副作用。

**纯函数就是没有副作用的函数**。纯函数，不会给任何外部变量赋值，不会修改输入参数，不会对数据库进行读写。

纯函数的基本思想就是：**相同的输入，永远会得到相同的输出**

纯函数也即数学意义上的函数，表达的是数据之间的转换（映射）关系，而非计算步骤的详述。

纯函数可以看作定义域到值域映射，待组合的函数中的上一个函数的值域须等于下一个函数的定义域，也即上一个函数的输出（类型）等于下一个的输入（类型）



## Immutability（数据不变性）

**Immutability指的是：一旦定义了某个值或者对象，那么就再也不能更改它啦。**

如果想要更改数组或者对象中的元素，需要返回带有修改值的新拷贝。也就是 **“以拷贝代替修改”**

Immutability 和 纯函数 息息相关。由于纯函数不允许有副作用，所以不允许更改函数体外部的数据结构。纯函数强制以 immutable 的方式处理数据。

> 无论一个数据是否是可变的，永远将他们看做不可变的。遵守这样的约定，你程序的可读性和可信赖度将会大大提升。

### 常量
常量：一个无法重新赋值 (reassignment) 的变量。
在js中，如果声明了一个引用类型的常量，实际上我们依然可以修改它的值！！！。
`Object.freeze()` 方法会遍历对象或者数组的每个属性和索引，将它们设置为只读。也会将属性标记为“不可配置（non-reconfigurable)”,并且使对象或者数组本身不可拓展（即不会被添加新属性）。注意：**使用这个方法仅仅是顶层不可变**。`Object.freeze()` 提供的是浅层的、初级的不可变性约束。如果你希望更深层次的不可变约束，那么就需要手动遍历整个对象或者数组结构来为所有后代应用 `Object.freeze()` 。



## curry(函数柯里化)
**柯里化是：把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，让其返回一个函数来处理其余的参数。**
**柯里化的作用是：可以指定分离实参的时机和地方。**
当函数只有一个形参时，我们能够比较容易的组合他们
柯里化的好处是：每次函数调用传入一个实参，并生成另一个特定性更强的函数，之后我们可以在程序中获取并使用那个新函数。而偏应用则是预先指定所有将被偏应用的实参，产生一个等待接受剩下所有实参的函数。



## 声明式编程和命令式编程
也可以这么说 `说明式编程` 和 `指令式编程` 。
通过这几句话感受一下
1. 声明式编程是告诉计算机需要计算“什么”而不是“如何”去计算
2. 它描述目标的性质，让计算机明白目标，而非流程。
3. 命令式编程中，程序员需要告诉计算机怎么做来完成任务，命令式编程带给我们每天会用到的大量的基本结构：控制流（`if`-`then`-`else` 语句和循环），算术运算符（`+`、`-`、`*`、`/`），比较运算符（`===`、`>`、`<` 等），和逻辑运算符（`&&`、`||`、`!`）。
4. 程序员只需告诉计算机我想要什么，然后计算机自己理清如何产生结果。
5. 类似于sql语句，你只需要告诉它你要查什么，而不用告诉它怎么查。
6. 我们讨论了如何用声明式编程（告诉计算机做什么，我们想要什么）代替命令式编程（告诉计算机该怎么做，详细的执行步骤）来编写代码。

在js中要想实现声明式编程，需要借助一些库，可以选择使用`Ramda`



## Pointfree 风格（无参数风格）

Pointfree 的本质就是使用一些通用的函数，组合出各种复杂运算。上层运算不要直接操作数据，而是通过底层函数去处理。这就要求，将一些常用的操作封装成函数。

在 pointfree 式编程时，实际上不会看到正在操作的数据参数，数据被隐含在函数中了。程序是由许多较小的、简单的构建模块组合而成。只有在最后才将组合后的函数应用于实际的数据上。



## function first
- **Function first**
- **数据放在最后**：几乎所有的函数都将数据参数作为最后一个参数。
- **柯里化**：Ramda 几乎所有的函数都是自动柯里化的。也即，可以使用函数必需参数的子集来调用函数，这会返回一个接受剩余参数的新函数。当所有参数都传入后，原始函数才被调用。



## 引用透明及缓存

在不改变整个程序行为的情况下，如果能将其中的一段代码替换为其执行的结果，我们就说这段代码是引用透明的。

我们可以使用一种叫做“等式推导”（equational reasoning）的技术来分析代码。所谓“等式推导”就是“一对一”替换，有点像在不考虑程序性执行的怪异行为（quirks of programmatic evaluation）的情况下，手动执行相关代码。

因此，执行一段引用透明的代码（函数），对于相同的参数，总是给出相同的结果。我们也称这样的函数（代码）为纯函数。也说这个函数是引用透明的。

引用透明的一个典型应用即函数缓存。我们可以将已经执行过的函数输入值缓存起来，下次调用时，若输入值相同，直接跳过计算过程，用缓存结果代替计算结果返回即可。

函数缓存的实现依赖于闭包，而闭包的实现又依赖于高阶函数，高阶函数的实现又依赖于一等函数。我们按照这条依赖链，从里往外依次对它们进行讲解。
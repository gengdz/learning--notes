# 插件系统
插件系统是 **由一个实现了插件化的核心模块和其配套的插件模块组成的** ***一种应用组织形式***， 其中核心模块能独立运行并实现某种特定的功能，插件模块需要在核心模块上运行，并能在应用程序运行时修改程序的处理方式，从而增强或改变程序的处理结果。


## 为什么要做插件化？
提升系统的可维护性。插件化能将不断扩张的功能分散在插件中，内部集中维护核心不变逻辑。

好处如下：
* **维护成本低**。只需要保证核心模块的稳定性
* **便于协同开发**。内核是插件是单向依赖的，插件和插件之间是无依赖的。开发团队和第三方人员都能拓展应用程序，这能够发挥生态的力量。
* **能够降低应用程序的大小**。通过插件的方式内核模块很小，用户只加载自己可用的插件，用户程序也很小。
* **轻松增加新功能**。在工具开发之初开发者很难就想全应用程序的所有功能，如果把所有功能都写入核心包可能会带来巨大的升级维护成本。但是通过插件系统这种方式，就可以在不影响核心功能基础上快速新增新的功能。



## 插件的形式
总的来说主要有下面几种插件化形式

* 约定式插件
* 注入式插件
* 事件式插件
* 插槽式插件 



### 约定式插件
依赖核心模块加载自身。

常见的如一些配置式配置。如约定式路由、根据目录结构来区分功能，如 Egg，不同的目录有不同的生命周期。在 Umi 中 plugin.ts 就是插件。



### 注入式插件
通常需要使用核心模块提供的 API 或生命周期，比如：
```typescript
export default function (api: IApi){
  api.logger.info('use plugin')

  api.modifyXxx()
}
```


### 事件式插件
通过事件的方式提供插件开发的能力，最常见比如 dom 事件：
```typescript
document.on("focus", callback);
```
虽然只是普通的业务代码，但这本质上就是插件机制：

* **可拓展**：可以重复定义 N 个 focus 事件相互独立。
* **事件相互独立**：每个 callback 之间互相不受影响。
也可以解释为，事件机制就是在一些阶段放出钩子，允许用户代码拓展整体框架的生命周期。


### 插槽式插件
React 中组件化基本就是一个个插件。一些代码可以通过更插件化的方式表达
```typescript
function Menu({ plugins }) {
	return <div clssName="my-menu">
		{plugins.map(p => <div clssName="my-menuitem" style={p.style}>{p.name}</div>)}
	<div>
}

```



## 如何实现插件化？
一般来说，要实现一个插件化能力，核心系统需要提供以下能力：
* 「必须」确定插件注册加载方式
* 「必须」 确定核心系统的生命周期和相关相关暴露 API
* 「非必须」对插件暴露合适范围的上下文，并对不同场景的上下文做隔离（通常是更复杂的插件系统，比如 vscode，chrome 插件）
* 「非必须」确定插件依赖关系
* 「非必须」确定插件和核心系统的通信机制


解析插件，注册插件，调用插件。



### 插件接入的方式
解析插件就是：找到所有的插件。
* 通过 npm 名：比如只要 npm 包符合某个前缀，就会自动注册为插件，例：Umi 约定，只要 npm 包的名称使用 @umijs 或者 umi-plugin 开头就会自动加载成插件。
* 通过文件名：比如项目中存在 xx.plugin.ts 会自动做到插件引用，这一般作为辅助方案使用。
* 通过代码：这个很基础，就是通过代码 require 就行，比如 babel-polyfill，不过这个要求插件执行逻辑正好要在浏览器运行，场景比较受限。
* 通过描述文件：这是比较常用的方式，几乎所有的插件系统都会提供一个入口描述文件，比如在 package.json或者对应的配置文件中描述一个属性，表明了要加载的插件，比如 .babelrc:



### 需要做的事情
面向接口编程。**定义插件需要实现的接口**，这是插件必须遵循的一个规范，基于这些规范，系统可以对插件进行检验、注册挂载、注销等操作。

插件的注册主要有两种模式
* 插件调用核心模块的注册方法，将自己注册到程序中
* 核心模块知道如何查找并加载插件。比如加载 plugins 下的文件。比如 Webpack 从配置文件中拉取插件。


## 一些思考

1. 定义好插件的接口。
2. 确定插件的接入方式
3. 给出一个生命周期。

下面这个函数，就是 Umi 在 resolveConfig stage 生命周期中会执行的 hook
```typescript
api.modifyConfig((memo, { path }) => {
  memo.alias = {
    ...memo.alias,
    '@': paths.absSrcPath
  }
  return memo;
})
```

## 参考资料
* [当我们说插件系统的时候，我们在说什么](https://juejin.cn/post/7209852595001884730#heading-5)
* [如何设计开发一个 Web 插件系统？](https://juejin.cn/post/6969467348184989727#heading-21)
* [开发Umi插件](https://umijs.org/docs/guides/plugins)
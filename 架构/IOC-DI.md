# IOC 和 DI

## 什么是IOC
IOC（Inversion of Control) 翻译为：**控制反转** 或者 **依赖倒置**。主要包含下面三个准则：
1. 高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象
2. 抽象不应该依赖于具体实现，具体实现应该依赖于抽象
3. 面向接口编程而不是面向实现编程

一些理解
控制：对对象的控制权，如创建和销毁
反转：由最初在类中手动创建对象反转为由Spring容器去创建

高层按照需要定义接口，底层按照高层定义的接口实现接口。 接口只是依赖倒置的实现方法之一

> * [前端中IOC概念](https://zhuanlan.zhihu.com/p/53832991)


## DI
DI(Dependency Injection) 依赖注入
简单说来就是把高模块所依赖的模块，通过一定的方式，把依赖注入到模块内部



## IOC和DI的关系
IOC是指导思想，DI是这个这个指导思想下的实践。


## 在React中的运用
为什么要用useFunc，不直接import数据和方法，因为状态逻辑的响应式控制权在框架手上
什么时候调用，什么时候更新视图的控制权也在框架甚至直接是组件节点手上，但是会通过各种 hooks api 反转给你，你就能将这些东西定义在任何文件任何useFunc中。
你对比class老版本，控制权没有反转时，你是不是状态和更新必须调用this上的api？那么这部分逻辑提取成服务就不可能办到。

反转指的是，很多时候问题的根源在于，react没有把变更和相应式的控制权给我我们我们。框架系统把内部逻辑的控制权给到开发者，就是控制反转。
useState 响应控制权
useEffect m-vm的响应式回调
useLayoutEffect vm-v的响应式回调
useMemo 调度控制权


不用担心纯度和不变性的问题，因为hooks都是纯的，没有不纯的情况。
全局副作用是状态+函数全局逻辑封装（分层）考虑的问题，将函数和组件，视图功能逻辑样式全部作为模块，副作用是以模块为单位的，而info和setInfo的getter，setter封装，叫做——模块间通讯
在这里props的功能好像只有 ‘分形’，也就是map中将数据的标示传递给子组件，

有共同单例Service的一系列组件，称为模块，它们有自己的 限界上下文，并且，视图，逻辑，样式都在其中，如果这个模块是按照功能划分的，那么这种SOA实现被称为 领域驱动设计。



### 可选服务
可选服务就是将逻辑变为可选项，

你也可以通过各种条件筛选服务，这种方式是在前端实现的高可用
注意，服务最好只是内部实现不同，接口应该尽可能相同，否者会出现可选类型



### 有了IOC之后，props的作用是什么呢？
除了影响调度（函数式组件）外，props其实在新版React中，**只起到 map 节点传递 迭代标示 或者 注入令牌的作用**


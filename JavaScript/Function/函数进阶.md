# 函数进阶

## 函数内部属性、函数属性和方法

### 函数内部属性
在函数内部有两个特殊的对象 ***arguments*** 和 ***this*** 。

arguments 是一个 **伪数组** ，包含着传入函数中的所有参数。(这个对象还有一个 callee 属性)，我们可以通过对 arguments 进行遍历等操作。拿到参数的值。

this 对象的值是函数执行的环境对象。如果在全局作用域内调用，那么 this 指向 Window 对象。



### 函数属性
在 EcmaScript 中函数也是对象，也有属性和方法，每个函数都有两个属性 `length`, `prototype` ;

* length 表示函数的参数的个数
* prototype 表示原型对象，默认指向 Object 空对象。原型对象中有一个 constructor，它指向函数对象。(也就是下面例子中 `Foo.prototype.constructor === Foo`)



### 函数方法

在 EcmaScript 中函数也是对象，也有属性和方法。这里重点说 3 个 `call()`、`apply()`、`bind()`。

* 作用是：改变函数执行时的 this 指向。
* 核心理念是：借用方法
* 只有函数才有这几个方法


## 函数拓展

### 原型对象添加属性和方法(一般为方法)

作用是函数中的所有实例对象都将自动拥有原型中的属性或方法。

```javascript
function Foo(x){
    // 这里就用到了函数内部属性 this
    this.x = x
}

// 这里就是给原型对象添加属性
Foo.prototype.y = 100
Foo.prototype.calculate = function(z){
    return this.x +this.y+ z
}

// test就是Foo的实例对象
const test = new Foo(20)
// 实例化之后就相当于给test绑定了__proto__，事实上同时绑定的还有constructor。
// 也就是说通过new的方式创建的对象自带上面两个属性
console.log(test.calculate(30)) ==> 20+100+30 =150

```



###  显示原型和隐式原型

（1）每一个 function 都有一个 prototype，这就是显示原型(默认指向一个空的 Object 对象)

（2）每个实例对象都有一个 `__proto__` ，可称为隐式原型

（3）对象的隐式原型的值 是其构造函数显示原型的值，其实就是 `test.__proto__ === Foo.Prototype`



### 参考

* [函数内部属性、函数属性和方法](https://blog.csdn.net/m0_37581397/article/details/81982670)
* [函数的prototype解析](https://blog.csdn.net/qq_16858683/article/details/79337329)



## 立即调用的函数表达式

Immediately-Invoked Function Expression 简写为 **IIFE**，

举例说明：

```javascript
(function(){ /* code */ }());

// 或者
(function(){ /* code*/ })();
```

**注意：后面的 `;` 必不可少**

再来一个例子感受下

```javascript
(function () {
  var tmp = newData;
  processData(tmp);
  storeData(tmp);
}());
```

通常情况下，只对匿名函数使用`立即调用的函数表达式`。目的有两个：一是不必为函数命名，避免了污染全局变量；二是内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量




## 空函数
```javascript
function noop(){}

// Function.prototype 等价与 noop
const {
    onChange = noop,
    onValueChange = Function.prototype

} = props
```
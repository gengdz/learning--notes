# 模块设计

将应用程序中的代码拆分成多个模块单元，每个模块单元具有独立的作用域和功能，模块之间通过导入和导出的功能进行通信和复用。

- 拆分方式目前都是按照文件的形式。每个文件就是一个模块。
- 模块是比对象和函数更大的单元。使用模块组织程序，便于维护和扩展

## 为什么要模块化

- 解决命名冲突。
- 提高代码复用性。
- 简化依赖管理。在开发的过程中会使用到第三方库和框架。通过模块化可以解决传统 JS 手动管理依赖的弊端：1. 不需要手动控制加载顺序了。
- 实现按需加载。`import('./module.js').then`

## 发展历史

模块加载方案

- AMD/CMD（浏览器端使用）
- CommonJS（Node.js）
- UMD（支持上面两种方式）
- ES6 Module

## AMD/CMD

用于浏览器端。

### AMD

AMD：Async Module Definition（异步模块定义）

主要实现：RequireJS

模块可以异步加载和使用，避免了在页面初始化时就加载所有模块带来的性能问题。

```js
// 定义一个模块
define('module', ['jquery'], function ($) {
  // 模块代码
  return {
    foo: function () {
      console.log('foo');
    },
    bar: function () {
      console.log('bar');
    },
  };
});

// 使用一个模块
require(['module'], function (module) {
  // 使用模块
  module.foo();
});

// 其中 jquery 通过如下方式配置路径
require.config({
  baseUrl: 'js',
  paths: {
    jquery: 'lib/jquery.min',
  },
});
```

这种模式中模块需要自己定义，而不是一个文件默认就是一个模块。

### CMD

CMD：Common Module Definition

主要实现：SeaJS

CMD 推荐将模块的加载和执行放到模块内部执行。好处是：简单直观。

```javascript
// 定义一个模块
define(function (require, exports, module) {
  // 引用其他模块
  var $ = require('jquery');

  // 模块代码
  function foo() {
    console.log('foo');
    $('body').css('background-color', 'red');
  }

  // 导出模块公共接口
  module.exports = {
    foo: foo,
  };
});

// 使用一个模块
var module = require('./module');
module.foo();
```

### 实现原理

```javascript
// 模块列表容器
const myModule = (function () {
  const moduleList = {};
  function define(name, modules, action) {
    const realModules = modules.map((module) => moduleList[module]);
    moduleList[name] = action.apply(null, realModules);
  }
  return { define };
})();

// 定义一个模块
myModule.define('G', [], () => {
  return {
    max(arr, key) {
      return arr.sort((a, b) => b[key] - a[key])[0];
    },
  };
});

// 使用一个模块
myModule.define('lesson', ['G'], (G) => {
  const lesson = [
    { name: 'js', price: 100 },
    { name: 'react', price: '200' },
  ];
  const max = G.max(lesson, 'price');
  console.log(max);
});
```

## CommonJS

这个用于服务器。

```javascript
// 定义一个模块
function foo() {
  console.log('foo');
}

// 导出模块
module.exports = {
  foo: foo,
};

// 加载一个模块
var module = require('./module');
module.foo();
```

运行时加载。

## UMD

UMD: Universal Module Definition(通用模块定义)。可以让模块在 CommonJS、AMD、CMD 三种环境中都可以运行。

```javascript
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD 环境
    define(['jquery'], factory);
  } else if (typeof exports === 'object') {
    // CommonJS 环境
    module.exports = factory(require('jquery'));
  } else {
    // 全局环境
    root.myModule = factory(root.jQuery);
  }
})(this, function ($) {
  // 模块代码
  function foo() {
    console.log('foo');
  }

  // 导出模块接口
  return {
    foo: foo,
  };
});
```

## 基础知识

### 标签使用

```html
<script type="module">
  import { name } from './1.js';
  console.log('name', name);
</script>
```

- 我们使用 `type="module"` 来表示开启模块功能。
- 这里需要注意路径要有 `./`，不然会报错。使用一些打包工具的时候，有的可以不加。
- 浏览器对于带有 `type="module"` 的 `<script>`，都是**异步加载**的，等同于同时打开了 `<script>` 的 `defer`

作用：

- 声明一个模块
- 这段 script 默认采用 defer 的形式加载

### 延迟解析

模块总是在所有 HTML 解析之后才执行。这个是因为，只有解析完了，才知道他们的依赖关系

```html
<body>
  <script type="module">
    lsfjlsj = 'aaa'; // 报错 没定义 严格模式
    console.log('module', document.querySelector('button')); // Button
  </script>
  <script>
    agsdfsfe = 'bbb'; // 不报错 非严格模式
    console.log('非 module', document.querySelector('button')); // null
  </script>
  <button>button</button>
</body>
```

- 当我们使用**模块**时，就**默认开启了严格模式**

### 作用域

模块是独立作用域，外部不可以访问。模块之间变量名也不会冲突

```html
<script type="module">
  let name = 'sss';
</script>

<script type="module">
  alert(name); // Error
</script>
```

### 预解析

模块在导入时只执行一次，之后的导入不会再执行模块代码，而是使用第一次解析的结果，并共享数据。

## 按需动态加载

使用 `import {} from 'xxx'` 这种必须在顶层使用。

我们可以使用 `import().then()` 的方式动态加载

```javascript
const handleClick = () => {
  import(aa.js).then((data) => {
    console.log(data);
  });
};
```

## 编译打包

编译是将 ES6+ 的语法转换为向后兼容的 JS 代码，这样旧版本的环境也能运行

```bash
"scripts": {
	"dev": "webpack --mode development --watch"
},
```

## import.meta

返回当前模块的元信息。开发者有是时候需要知道模板本身的一些信息（比如模块的路径）

## 经验

ESM 的包可以通过 `import { } from 'xx'` 的方式使用类型不会报错，其他规范的包需要通过 `import type { } from 'xx'` 来导入，否则就报错。

# 优雅示例


## 你需要原始数据 *data$*,又需要由他衍生出来的 *resultData$*
这时候，可以使用 `mergeMap + from/of + map`。
```javascript
data$.pipe(
  mergeMap(data) => from(list).pipe(
    // 在这里做转换，生成 resultData$.
    map(v => ({ data, resultData }))
  ))
)
```



## 当值变化的时候，需要调用api，返回值是一个数组，然后需要对返回的数组做一些操作，可以采用下面的方式，先打散，然后再 toArray 
```javascript
word$.pipe(
  switchMap(word => from(getUser(word)).pipe(
    mergeMap(data => form(data)),
    take(5),
    toArray(),
    retry(2),
  ))
)
```



## complex-flatten
```javascript
const flattenArray = (data) =>
  from(data).pipe(
    filter((v) => !!v),
    mergeMap((v) => {
      if (Array.isArray(v)) {
        return from(v);
      } else if (v?.props?.children) {
        return flattenArray(from(v.props.children));
      } else {
        return of(v);
      }
    })
  );

const data = [
  1,
  null,
  [2, 3],
  {
    props: {
      children: [
        4,
        5,
        null,
        [6, 7],
        {
          props: {
            children: [8, 9, 10]
          }
        }
      ]
    }
  }
];
  
// 使用如下
flattenArray(data).subscribe(console.log); //=> 1, 2, 3, 4, 5
flattenArray(data).pipe(toArray()).subscribe(console.log); //=> [1, 2, 3, 4, 5]
```
# 基础

[toc]

## 为什么有 vite？

原因：项目越大，构建工具处理的代码越多，这和 webpack 的工作流程有关
结果：冷启动，热更新 很慢

为什么 webpack 不行

webpack 没法直接改变先有流程，比如可以在同一代码中写两种模块规范的代码。用户体量太大

因为 webpack 支持多种模块规范，所以在启动的时候要把多种转换为自己的那一种，webpack_require，所以意味着 webpack 需要把所有依赖都读一遍，所以造成启动慢

webpack 更多的做的是兼容，浏览器端和服务器端，vite 关注浏览器端的开发体验

## vite 为什么快

区分 **依赖**和**源码**
**依赖**使用 esbuild 做**依赖预构建**。esbuild 本身快
**源码**默认使用 ESM 的模块规范，所以不需要构建所有代码，先启动服务器，加载入口文件，需要哪个页面代码就转换按需提供源码。

## 依赖预构建

依赖预构建：找到对应的依赖，使用 esbuild,将多个规范的依赖转换成 ESM 规范，然后放在当前目录下的 node_modules/.vite/deps 中。
需要解决的问题：

1. 模块规范兼容。有的依赖使用 CommonJS 规范，有的使用 UMD 规范，在开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将以 CommonJS 或 UMD 形式提供的依赖项转换为 ES 模块。

2. 性能。有的 ES 模块可能包含了很多个导出的模块，比如：lodash-es，超过 600 个内置模块，这样会发 600 多次请求。性能差，需要把它们合并成一个或者多个文件。

3. 路径补全优化。在补全路径的时候，可以直接读 node_modules/.vite/deps，方便路径重写

optimizeDeps 依赖预构建相关的配置。

- include，哪些包要依赖预构建
- exclude，哪些包不要依赖预构建

## 为什么生产环境要打包

因为每个导入都要发接口，依赖的依赖也会发接口，如果不打包接口的数量将会非常大，性能太差。

这也是为什么 ESM 为什么不默认帮我们从 node_modules 读取文件的原因：
既然最佳实践是 node_modules，那么为什么在导入非绝对路径和相对路径的时候，esm 不默认帮我们从 node_modules 读取?
因为每个 import 都要发接口，依赖的依赖也会发接口，接口的数量将会非常大，性能太差。

为什么服务端可以做？
因为服务端不是通过网络请求，而是通过本地文件内存中的东西

## 怎么解析模块

开发环境下：
如果遇到非绝对路径和相对路径的代码比如：

```typescript
import React from "react";
```

vite 会尝试进行**路径补全**，补全成下面的样子

```typescript
import React from "/node_modules/.vite/deps/react.js";
```

## 开发环境和生产环境配置

可以根据 command 来区分。

```typescript
export default defineConfig(({ command, mode }) => {
// command 只有两种 serve 和 build
}
```

## 环境变量处理

`mode` 是你在命令行输入命令时通过 `--mode dev` 指定的。如果你不指定，那么 vite 命令默认环境变量就是 `development`，vite build 环境变量就是 `production`。

vite 集成了 dotenv 库，这个库会读取 .env 文件，并将其内容放在 process 对象中。但是 vite 考虑到和其他配置的一些冲突问题，所以不会直接将其放入到 process 对象中。
这两个配置项 root, envDir 会影响 env 的生成。

vite 提供了 loadEnv 函数，会读取 .env 文件，同时还会读取 .env.[mode] 文件
process.cwd() 返回当前 node 进程的工作目录。

在 node 环境下运行时会把这些环境变量放在 process 对象里面。

在浏览器环境下运行时会把这些环境变量放在 import.meta 里面
同时 vite 为了防止把任意的环境变量塞进 meta，所以规定**需要加一个前缀才能识别**。默认的前缀是 `VITE`，可以通过：`envPrefix` 来修改。

为什么 vite.config.js 可以写成 esm 的形式？是因为 vite 在解析到这个文件的时候，他会检测，如果你用的是 esm，它会转化成 commonjs 的形式。

## vite 打包生成的 HTML 解析

head 中的代码

```html
<script type="module">
  import.meta.url;
  import("_").catch(() => 1);
  async function* g() {}
  if (location.protocol != "file:") {
    window.__vite_is_modern_browser = true;
  }
</script>
```

这段代码中作用是为了检测浏览器对模块以及对语法的支持程度。
如果不支持，就停止执行。
如果支持，就打上一个是现代浏览器的标识。

上面语法检测了 import.meta、动态导入、异步生成器。这样可以使 Vite 后续更准确的判断该加载哪些 JS。

head 中的代码

```html
<script type="module">
  !(function () {
    if (window.__vite_is_modern_browser) return;
    console.warn(
      "vite: loading legacy chunks, syntax error above and the same error below should be ignored",
    );
    var e = document.getElementById("vite-legacy-polyfill"),
      n = document.createElement("script");
    (n.src = e.src),
      (n.onload = function () {
        System.import(
          document.getElementById("vite-legacy-entry").getAttribute("data-src"),
        );
      }),
      document.body.appendChild(n);
  })();
</script>
```

这段代码的作用是如果是现代浏览器直接返回。

如果支持 module，但是不支持 import.meta、动态导入、异步生成器。那么走后面的内容：Vite 使用 SystemJs 加载了带有 legacy 标记的文件。

body 代码

```html
<script nomodule>
  !(function () {
    var e = document,
      t = e.createElement("script");
    if (!("noModule" in t) && "onbeforeload" in t) {
      var n = !1;
      e.addEventListener(
        "beforeload",
        function (e) {
          if (e.target === t) n = !0;
          else if (!e.target.hasAttribute("nomodule") || !n) return;
          e.preventDefault();
        },
        !0,
      ),
        (t.type = "module"),
        (t.src = "."),
        e.head.appendChild(t),
        t.remove();
    }
  })();
</script>
<script
  nomodule
  crossorigin
  id="vite-legacy-polyfill"
  src="/polyfills-legacy.js"
></script>
<script nomodule crossorigin id="vite-legacy-entry" data-src="/index-legacy.js">
  System.import(
    document.getElementById("vite-legacy-entry").getAttribute("data-src"),
  );
</script>
```

如果浏览器不支持模块化就会执行这里的代码。

有一个问题：如果有浏览器即支持模块化，但是不支持 import.meta、动态导入、异步生成器。那么就会导致：同时加载了 原生模块的文件和兼容文件。

这里面的逻辑会执行两次吗？
不会。

因为在 index.js 中有如下代码

```js
function __vite_legacy_guard() {
    import.meta.url;
    import("_").catch(() => 1);
    async function* g() {};
};

(function polyfill() {
    // 后续其他逻辑不在这里贴了，可以使用 Vite 自行打包查看
    ...
})();

```

这样，如果加载了原生文件因为不支持这个函数，就会报错，就不会往下执行。这么就只会执行兼容文件。

[Vite 是怎么兼容老旧浏览器的？](http://www.it120.vip/yq/11866.html)

## vite 是怎么处理样式 CSS/SCSS

### 处理 CSS 的流程

vite 中通过 css 属性 控制整个css行为

1. vite在读取到main.js中引用到了index.css
2. 直接去使用fs模块去读取index.css中文件内容
3. 直接创建一个style标签，将index.css中文件内容直接copy进style标签里
4. 将style标签插入到index.html的head中
5. 将该css文件中的内容直接替换为js脚本(方便热更新或者css模块化),同时设置Content-Type为js 从而让浏览器以JS脚本的形式来执行该css后缀的文件

```typescript
css: {
  devSourcemap: true, // 是否生成类名的映射
  modules: {
    localsConvention: 'camelCaseOnly', // 在 JS 文件只能通过驼峰的方式引用 CSS 类名
    generateScopedName: '[name]-[local]-[hash:base64:5]', // 生成的类名格式
    globalModulePaths: [/path\/to\/legacy-styles/], // 不想参与到css模块的路径
  },
  preprocessorOptions: {
    scss: {},
    less: {},
  },
  postcss: {
    plugins: [postcssPresetEnv()],
  },
},

```

### css.devSourcemap

开启类名映射

解决的问题：
如果开启了 css module 模块化方案，我们能看到的样式是编译之后的：类名是处理过的、同时索引时定位到的是 style 里面。当开了 devSourcemap 之后就可以定义到原文件了。

`devSourcemap: true,`

### css.modules 模块化方案

解决样式冲突问题 `modules`

使用的方案是：css.modules
大概说一下原理：
全部都是基于node

1. x.module.css （module是一种约定，表示需要开启css模块化）
2. 他会将你的所有类名进行一定规则的替换（将footer 替换成\_footer_i22st_1）
3. 同时创建一个映射对象{ footer:"\_footer_i22st_1"}
4. 将替换过后的内容塞进style标签里然后放入到head标签中（能够读到index.html的文件内容)
5. 将componentA.module.css内容进行全部抹除，替换成JS脚本
6. 将创建的映射对象在脚本中进行默认导出

配置选项：

- localsConvention
- generateScopeName
- globalModulePaths

css 写的时候用中划线，在js用的时候按照规范是要驼峰，可以通过 localsConvention 来指定方式

localsConvention 的几种配置

- camecase 驼峰 和 原写法都在
- camecaseonly 只要驼峰

generateScopeName 配置生成的类名的规则: `"[name]-[local]-[hash:base64:5]"`

globalModulePaths 不想参与到css模块的路径

### css.preprocessorOptions 配置预处理器

**所有预处理器选项还支持 `additionalData` 选项，可以用于为每个样式内容注入额外代码。**
请注意，如果注入的是实际的样式而不仅仅是变量时，那么这些样式将会在最终的打包产物中重复出现。

#### less

lessc 编译 less 的。

`globalVars` 配置全局变量。这样就不要在使用的时候频繁导入全局变量文件了。

在 webpack 中 给 less-loader 配置就好了。

#### scss

### css.postcss

对css 语法进行编译，保证低版本的兼容，对语法降级，前缀补全。

vite天生对postcss有非常良好的支持

postcss 他的工作：保证css在执行起来是万无一失的

我们写的css代码(怎么爽怎么来)--> postcss --->【去将语法进行编译(嵌套语法,函数,变量)成原生css】less sass等预处理器都可以做-->再次对未来的高级css语法进行降级-->前缀补全-->浏览器客户端

我们写的js代码(怎么爽怎么来)--> babel -->将最新的ts语法进行转换js语法-->做一次语法降级-->浏览器客户端去执行[babel -->帮助我们让js执行起来万无一失

有人对 postcss有误区，认为他和 less sass差不多级别的，实际上 postcss ＞ less 的，

通过 css.postcss 配置
配置插件 postcsspresetenv 这里面包含了基本要用到的插件集，比如语法降级
postcss-less 预处理器停止维护啦，需要自己吧less编译成css，


## 

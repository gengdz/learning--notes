# 基础

## 为什么有 vite？

原因：项目越大，构建工具处理的代码越多，这和 webpack 的工作流程有关
结果：冷启动，热更新 很慢

为什么 webpack 不行

webpack 没法直接改变先有流程，比如可以在同一代码中写两种模块规范的代码。用户体量太大

因为 webpack 支持多种模块规范，所以在启动的时候要把多种转换为自己的那一种，webpack_require，所以意味着 webpack 需要把所有依赖都读一遍，所以造成启动慢

webpack 更多的做的是兼容，浏览器端和服务器端，vite 关注浏览器端的开发体验

## vite 为什么快

区分 **依赖**和**源码**
**依赖**使用 esbuild 做**依赖预构建**。esbuild 本身快
**源码**默认使用 ESM 的模块规范，所以不需要构建所有代码，先启动服务器，加载入口文件，需要哪个页面代码就转换按需提供源码。

## 依赖预构建

依赖预构建：找到对应的依赖，使用 esbuild,将多个规范的依赖转换成 ESM 规范，然后放在当前目录下的 node_modules/.vite/deps 中。
需要解决的问题：

1. 模块规范兼容。有的依赖使用 CommonJS 规范，有的使用 UMD 规范，在开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将以 CommonJS 或 UMD 形式提供的依赖项转换为 ES 模块。

2. 性能。有的 ES 模块可能包含了很多个导出的模块，比如：lodash-es，超过 600 个内置模块，这样会发 600 多次请求。性能差，需要把它们合并成一个或者多个文件。

3. 路径补全优化。在补全路径的时候，可以直接读 node_modules/.vite/deps，方便路径重写

## 为什么生产环境要打包

因为每个导入都要发接口，依赖的依赖也会发接口，如果不打包接口的数量将会非常大，性能太差。

这也是为什么 ESM 为什么不默认帮我们从 node_modules 读取文件的原因：
既然最佳实践是 node_modules，那么为什么在导入非绝对路径和相对路径的时候，esm 不默认帮我们从 node_modules 读取?
因为每个 import 都要发接口，依赖的依赖也会发接口，接口的数量将会非常大，性能太差。

为什么服务端可以做？
因为服务端不是通过网络请求，而是通过本地文件内存中的东西

## 怎么解析模块

开发环境下：
如果遇到非绝对路径和相对路径的代码比如：

```typescript
import React from 'react';
```

vite 会尝试进行**路径补全**，补全成下面的样子

```typescript
import React from '/node_modules/.vite/deps/react.js';
```

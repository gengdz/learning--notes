# 基础

## 为什么有 vite？

原因：项目越大，构建工具处理的代码越多，这和 webpack 的工作流程有关
结果：冷启动，热更新 很慢

为什么 webpack 不行

webpack 没法直接改变先有流程，比如可以在同一代码中写两种模块规范的代码。用户体量太大

因为 webpack 支持多种模块规范，所以在启动的时候要把多种转换为自己的那一种，webpack_require，所以意味着 webpack 需要把所有依赖都读一遍，所以造成启动慢

webpack 更多的做的是兼容，浏览器端和服务器端，vite 关注浏览器端的开发体验

## vite 为什么快

区分 **依赖**和**源码**
**依赖**使用 esbuild 做**依赖预构建**。esbuild 本身快
**源码**默认使用 ESM 的模块规范，所以不需要构建所有代码，先启动服务器，加载入口文件，需要哪个页面代码就转换按需提供源码。

## 依赖预构建

依赖预构建：找到对应的依赖，使用 esbuild,将多个规范的依赖转换成 ESM 规范，然后放在当前目录下的 node_modules/.vite/deps 中。
需要解决的问题：

1. 模块规范兼容。有的依赖使用 CommonJS 规范，有的使用 UMD 规范，在开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将以 CommonJS 或 UMD 形式提供的依赖项转换为 ES 模块。

2. 性能。有的 ES 模块可能包含了很多个导出的模块，比如：lodash-es，超过 600 个内置模块，这样会发 600 多次请求。性能差，需要把它们合并成一个或者多个文件。

3. 路径补全优化。在补全路径的时候，可以直接读 node_modules/.vite/deps，方便路径重写

optimizeDeps 依赖预构建相关的配置。

- include，哪些包要依赖预构建
- exclude，哪些包不要依赖预构建

## 为什么生产环境要打包

因为每个导入都要发接口，依赖的依赖也会发接口，如果不打包接口的数量将会非常大，性能太差。

这也是为什么 ESM 为什么不默认帮我们从 node_modules 读取文件的原因：
既然最佳实践是 node_modules，那么为什么在导入非绝对路径和相对路径的时候，esm 不默认帮我们从 node_modules 读取?
因为每个 import 都要发接口，依赖的依赖也会发接口，接口的数量将会非常大，性能太差。

为什么服务端可以做？
因为服务端不是通过网络请求，而是通过本地文件内存中的东西

## 怎么解析模块

开发环境下：
如果遇到非绝对路径和相对路径的代码比如：

```typescript
import React from 'react';
```

vite 会尝试进行**路径补全**，补全成下面的样子

```typescript
import React from '/node_modules/.vite/deps/react.js';
```

## 开发环境和生产环境配置

可以根据 command 来区分。

```typescript
export default defineConfig(({ command, mode }) => {
// command 只有两种 serve 和 build
}
```

## 环境变量处理

`mode` 是你在命令行输入命令时通过 `--mode dev` 指定的。如果你不指定，那么 vite 命令默认环境变量就是 development，vite build 环境变量就是 production。

vite 集成了 dotenv 库，这个库会读取 .env 文件，并将其内容放在 process 对象中。但是 vite 考虑到和其他配置的一些冲突问题，所以不会直接将其放入到 process 对象中。
这两个配置项 root, envDir 会影响 env 的生成。

vite 提供了 loadEnv 函数，会读取 .env 文件，同时还会读取 .env.[mode] 文件
process.cwd() 返回当前 node 进程的工作目录。

在 node 环境下运行时会把这些环境变量放在 process 对象里面。

在浏览器环境下运行时会把这些环境变量放在 import.meta 里面
同时 vite 为了防止把任意的环境变量塞进 meta，所以规定**需要加一个前缀才能识别**。默认的前缀是 `VITE`，可以通过：`envPrefix` 来修改。

为什么 vite.config.js 可以写成 esm 的形式？是因为 vite 在解析到这个文件的时候，他会检测，如果你用的是 esm，它会转化成 common js 的形式。

## vite 打包生成的 HTML 解析

head 中的代码

```html
<script type="module">
  import.meta.url;
  import('_').catch(() => 1);
  async function* g() {}
  if (location.protocol != 'file:') {
    window.__vite_is_modern_browser = true;
  }
</script>
```

这段代码中作用是为了检测浏览器对模块以及对语法的支持程度。
如果不支持，就停止执行。
如果支持，就打上一个是现代浏览器的标识。

上面语法检测了 import.meta、动态导入、异步生成器。这样可以使 Vite 后续更准确的判断该加载哪些 JS。

head 中的代码

```html
<script type="module">
  !(function () {
    if (window.__vite_is_modern_browser) return;
    console.warn(
      'vite: loading legacy chunks, syntax error above and the same error below should be ignored'
    );
    var e = document.getElementById('vite-legacy-polyfill'),
      n = document.createElement('script');
    (n.src = e.src),
      (n.onload = function () {
        System.import(
          document.getElementById('vite-legacy-entry').getAttribute('data-src')
        );
      }),
      document.body.appendChild(n);
  })();
</script>
```

这段代码的作用是如果是现代浏览器直接返回。

如果支持 module，但是不支持 import.meta、动态导入、异步生成器。那么走后面的内容：Vite 使用 SystemJs 加载了带有 legacy 标记的文件。

body 代码

```html
<script nomodule>
  !(function () {
    var e = document,
      t = e.createElement('script');
    if (!('noModule' in t) && 'onbeforeload' in t) {
      var n = !1;
      e.addEventListener(
        'beforeload',
        function (e) {
          if (e.target === t) n = !0;
          else if (!e.target.hasAttribute('nomodule') || !n) return;
          e.preventDefault();
        },
        !0
      ),
        (t.type = 'module'),
        (t.src = '.'),
        e.head.appendChild(t),
        t.remove();
    }
  })();
</script>
<script
  nomodule
  crossorigin
  id="vite-legacy-polyfill"
  src="/polyfills-legacy.js"
></script>
<script nomodule crossorigin id="vite-legacy-entry" data-src="/index-legacy.js">
  System.import(
    document.getElementById('vite-legacy-entry').getAttribute('data-src')
  );
</script>
```

如果浏览器不支持模块化就会执行这里的代码。

有一个问题：如果有浏览器即支持模块化，但是不支持 import.meta、动态导入、异步生成器。那么就会导致：同时加载了 原生模块的文件和兼容文件。

这里面的逻辑会执行两次吗？
不会。

因为在 index.js 中有如下代码

```js
function __vite_legacy_guard() {
    import.meta.url;
    import("_").catch(() => 1);
    async function* g() {};
};

(function polyfill() {
    // 后续其他逻辑不在这里贴了，可以使用 Vite 自行打包查看
    ...
})();

```

这样，如果加载了原生文件因为不支持这个函数，就会报错，就不会往下执行。这么就只会执行兼容文件。

[Vite 是怎么兼容老旧浏览器的？](http://www.it120.vip/yq/11866.html)


## vite 是怎么处理样式 css/scss 




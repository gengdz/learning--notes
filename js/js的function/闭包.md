# 作用域和闭包
## 作用域和环境
* 全局作用域只有一个，并且不会被回收。每个函数又都有自己的作用域。
* 作用域链只向上查找，找到全局window即终止。应该尽量不要在全局作用域中添加变量。
* 函数被执行后其环境变量将从内存中删除。函数在每次执行后将会删除函数内部的变量
* 函数每执行一次都会创建一个新作用域，开辟一个内存空间。比如多次调用 `show()` 。但是 **如果子函数被使用，那么其父级环境将被保留**，也就是说：**如果环境定义的数据被使用，那么它就不会被回收。**
* 块作用域：使用 `let | const` 可以将变量声明在块作用域中。



## 闭包
### 闭包是用来解决什么问题的？
理解闭包必须要理解 *变量作用域*，js 有两种作用域：**全局作用域** 和 **函数作用域** ，函数内部可以直接读取全局作用域，但是函数外部无法读取函数内部定义的变量。

那么通过什么方式可以实现函数外部读取到函数内定义的局部变量呢？

答案是通过让函数返回一个函数的方式，就可以读取到。这时候可以理解为`函数 f2 + n` 就是一个闭包，即能够读取其他函数内部变量的函数。闭包最大的特点就是：它可以记住诞生的环境

```javascript
function f1() {
  const n = 999;
  function f2() {
    console.log(n);
  }
  return f2;
}

const result = f1();
result(); // 999
```

基于此，闭包的最大用处有两个
* **读取函数内部的变量**
* **让这些变量始终保存在内存中，即闭包可以使得他的诞生环境一直存在**



### 什么是闭包？
闭包没有具体不变的定义。下面的描述很好表达了闭包
> 闭包是指：**内部函数可以访问外部函数作用域的函数特性**。
> 闭包是指：**「函数」和「函数内部能访问到的变量」的总和**

闭包中保存的变量并不会在函数执行后自动销毁，只要内部函数依然存在对变量的引用，变量就会一直保留


### 感受一下闭包

```javascript
function makeAdder(x) {
  return function(y) {
    return x + y;
  };
}

const add5 = makeAdder(5);
const add10 = makeAdder(10);

console.log(add5(2));  // 7
console.log(add10(2)); // 12
```

```javascript
function Person(name) {
  const _age;
  function setAge(n) {
    _age = n;
  }
  function getAge() {
    return _age;
  }

  return {
    name: name,
    getAge: getAge,
    setAge: setAge
  };
}

const p1 = Person('张三');
p1.setAge(25);
p1.getAge() // 25
```

这里可以看到闭包的另一个作用就是，**封装对象的私有属性和私有方法**



### 内存泄漏和闭包
*内存泄漏* 是指：**用不到（访问不到）的变量，依然占据着内存空间，不能被再次利用起来。**
闭包里面的变量是我们需要的变量，不是内存泄漏。
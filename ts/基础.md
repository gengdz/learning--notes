#  Typescript基础



## 原始数据类型

js的类型分为两种：*原始数据类型* 和 *对象类型* 。

* 原始数据类型包括：boolean, number, string, null, undefined, Symbol, BigInt
* 对象类型：Array, Function, Date, RegExg

**ts对js的类型进行拓展**

* 原始类型增加了: void



### 使用说明和示例

```typescript
// boolean
const flag: boolean = false;

// number
const num: number = 20;

// string
const str: string = 'hello';

// null 和 undefined
const u: undefined = undefined;
const n: null = null;

// 这样不会报错
let num: number = undefined;

// void
const showName = (name: string): void => {
  console.log(name)
}

```

说明：

1. *undefined* 和 *null* 是所有类型的子类型。也就是说 *undefined* 类型的变量 可以赋值给 *number* 类型的变量 
2. *void* 表示没有任何返回值，只能将其赋值为 *undefined* 或者 *null*



## 任意值

使用 `any` 表示允许赋值为任意类型。

### 任意值的属性和方法

使用任意值之后，

1. 可以访问任何属性
2. 可以调用任何方法
3. 任意值进行任何操作，其返回值的类型为任意类型
4. 未声明类型的变量，会被默认声明为任意类型



## 类型推导

如果没有明确的指定类型，那么ts会依照类型推导的规则推断出一个类型

比如

```typescript
let age = 24;
age = 'six';
// 会报错。类型推导age为number，手动赋值为string。这时候就会报错

let age;
age = 24;
age = 'six';
// 不会报错。未声明类型的变量，会被默认声明为任意类型，任意类型可以进行任意操作，然后得到任意值。

```



## 联合类型和类型别名

联合类型：**目标值的类型可以为多个类型中的一种**。`string | number` 就称为联合类型。多个类型间使用 `|` 分割开。

类型别名：就是**给联合类型起个别名**。使用关键字 `type`。 比如：`type StringOrNumber = string | number`。

```typescript
// string | number 就称为联合类型、
// StringOrNumber 就是给联合类型起个别名
type StringOrNumber = string | number

// 下面是正常使用
let myNameOrAge : StringOrNumber = 10
myNameOrAge = '小明'
```



## 对象的类型

在ts中，使用接口 <small>(interface)</small> 来定义对象的类型。



### 什么是接口？

接口是对行为的抽象。具体的实现需要类去实现。

在ts中，interface 用来：

1. 对 *类的一部分行为* 进行抽象
2. 对 *对象的形状* 进行描述



### 使用说明

```typescript
interface PersonA {
  readonly id: number;
  name: string;
  age: number;
  favoriteFood?: string[]; // 可选属性
  [propName: string]: string | number | string[]; // 任意属性
}

const tom: PersonA = {
  name: 'tom',
  age: 16,
}
console.log(tom)
```

* 定义的变量比接口少了一些属性是不允许的，多一些属性也是不行的。必有的一定要有，且不能少也不能多。也就是说 **变量的形状必须和接口的形状保持一致**
* 可选属性：使用 `?` 表示。可选属性表示 这个属性可有可无。
* 任意属性：可以通过 `[propName: string]: any`。定义任意属性。但是必须要注意
  * **一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它类型的子集**
  * 一个接口只能定义一个任意类型。
* 只读属性：使用 `readonly` 定义只读属性。注意：
  * **只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候**



## 数组的类型
使用方式一：使用 `类型[]` 这种形式来表示。
使用方式二：使用 `Array<类型>` 这种形式来表示。

```typescript
const sorce: number[] = [1,2, 3];
const sorce: (number | string )[] = [1,'2',3];
const sorce: Array<number | string> = [1, '2', 3];
```


## 函数的类型

### 使用方式
```typescript
函数表达式的方式 不存在变量提升。
const getAli = (list: IOption[]) => list.filter(item => item.value === 'ali');
```



### 可选参数
* 同样使用 `?` 来表示是可选参数
* 可选参数必须放在必需参数的后面

```typescript
const getItem = (list: IOption[], targetValue?: string) => list.filter(item => item.value === (targetValue || 'ali'));
consoleLog('无可选参数，打印阿里:', getItem(dictionaryList));
consoleLog('存在可选参数，打印相应的值:', getItem(dictionaryList, 'v'));
```



### 参数默认值
* ts会将添加了默认值的参数识别为可选参数
* 这时候就不受 【可选参数必须放在必需参数的后面】的限制了。
```typescript
const getItemWithDefault = (list: IOption[], targetValue = 'ali') => list.filter(item => item.value === targetValue)
consoleLog('使用参数默认值:', getItemWithDefault(dictionaryList))
consoleLog('不使用默认值:', getItemWithDefault(dictionaryList, 'v'))
```


## 类型断言
手动指定一个值的类型。

两种写法
* `<类型>值` 
* `值 as 类型` --> 在tsx中必须使用这种类型

可以统一使用 `值 as 类型`这种方式。



### 使用场景
多在 `if 语句` 中使用。 <small>如果是其中一个类型，就执行某些操作。</small>
* 将一个联合类型断言为其中的一个类型
* 将父类断言为更具体的子类
* 将任何一个类型断言为 *any*
* 将any断言为一个具体的类型

```typescript
function getLength(something: string | number): number {
    if ((<string>something).length) {
        return (<string>something).length;
    } else {
        return something.toString().length;
    }
}
```

```typescript
export default { name: gdz, age: 25 } as PersonProfile
```



## class

类是对一件事物的抽象。里面有属性和方法。

对象是类的实例。`obj = new Animal()`

面向对象有三大特性：`封装`、`继承`、`多态`

### 类、继承、多态

一、ts中的类

```typescript
// ts中的类
class Animal {
  private name: string;
  constructor(name: string) {
    this.name = name
  }
  static nikeName: string = '小动物'
  getName(): string {
    return this.name
  }
  setName(name: string): void {
    this.name = name
  }
  sayHi(): string {
    return `my name is ${this.name}`
  }  
  static eat() {
    return `${this.nikeName}在吃东西`
  }
}

let a1 = new Animal('张三')
console.log(a1.getName())
a1.setName('张三的小名')
console.log(a1.sayHi())
console.log(Animal.nikeName)
console.log(Animal.eat())

// 张三
// my name is 张三的小名
// 小动物
// 小动物在吃东西
```

二、ts中的继承

```typescript
// 类的继承，通过 extends、constructor、super 实现
class Dog extends Animal {
  constructor(name: string) {
    super(name)
  }
  sayHi() {
    return `我是Dog类，我的名字是${this.getName()}`
  }
}

let dog = new Dog('狗子')
dog.setName('小狗子')
console.log(dog.sayHi())
console.log(Dog.nikeName)
console.log(Dog.eat())

// 我是Dog类，我的名字是小狗子
// 小动物
// 小动物在吃东西
```

三、多态

什么是多态？**父类定义一个方法，不去子类去实现。每个子类有不同的表现。多态属于继承的范畴**

```typescript
// Dog类继承了Animal,实现了sayHi方法
class Dog extends Animal {
  constructor(name: string) {
    super(name)
  }
  sayHi() {
    return `我是Dog类，我的名字是${this.getName()}`
  }
}

// Cat类继承了Animal,也实现了sayHi方法
class Cat extends Animal {
  constructor(name: string) {
    super(name)
  }
  sayHi() {
    return `我是Cat类，我的名字是${this.getName()}`
  }
}

let dog = new Dog('狗子')
console.log(dog.sayHi())

let cat = new Cat('猫咪')
console.log(cat.sayHi())

// 我是Dog类，我的名字是小狗子
// 我是Cat类，我的名字是猫咪

```

### 抽象类和抽象方法

一、为什么会出现抽象类和抽象方法？

***用来定义规范*** 。**父类定义了一些方法，他要求继承他的所有子类都实现这些方法**，在这个场景下就使用抽象类和抽象方法。

抽象类不能不能被实例化，只能继承他。继承了他就要重写他的抽象方法

二、代码示例

```typescript
// 抽象方法和抽象类
abstract class Person {
  name: string
  constructor(name: string) {
    this.name = name
  }
  abstract eat(): string
}

class Student extends Person {
  eat() {
    return `${this.name}同学在食堂吃饭`
  }
}

const student = new Student('耿德洲')
console.log(student.eat())
// 耿德洲同学在食堂吃饭
```



### 类里面的修饰符

| 修饰符              | 范围                                           |
| ------------------- | ---------------------------------------------- |
| publice(公有)       | 在类里面、子类、类外面都可以访问。<br />默认值 |
| protected(保护类型) | 在类里面、子类可以被访问                       |
| private(私有)       | 在类里面可以被访问                             |

### 类的总结

* 静态属性和方法可以被继承
* 静态方法中只能使用静态属性

---



## interface

一、为什么出现interface?

***用来定义更严格的规范***  

### 定义对象的形状

```typescript
interface PersonA {
  name: string;
  age: number;
  favoriteFood?: string[];
}

const tom: PersonA = {
  name: 'tom',
  age: 16,
}
console.log(tom)
// { name: 'tom', age: 16 }
```

### 定义函数的形状

```typescript
interface SearchFunc {
  (source: string, subString: string): boolean;
}

let mySearch: SearchFunc = function (source, subString) {
  return source.search(subString) !== -1;
}

console.log(mySearch('mySearch', 'my'))
// true
```

### 定义数组的形状

```typescript
// 使用接口来表示数组 (一般用于类数组)
interface NumberArray {
  [index: number]: number;
}

let fibonacci: NumberArray = [1, 1, 2, 3, 5]
```

### 接口继承接口，类实现接口

```typescript
// 接口继承接口，类实现接口
interface Cap {
  showColor(): string
}

interface BoliCap extends Cap {
  showName(): string
}

class MyCap implements BoliCap {
  name: string;
  color: string;
  constructor(name: string, color: string) {
    this.name = name;
    this.color = color
  }
  showColor(){
    return  `杯子的颜色:${this.color}`
  }
  showName(){
    return `杯子的名字: ${this.name}`
  }
}

const cap = new MyCap('扣扣','青色')
console.log(cap.showColor())
console.log(cap.showName())
// 杯子的颜色:青色
// 杯子的名字: 扣扣
```



## 理解两个关键字(typeof,in)

前置知识：

> `type` 用来给一个类型起别名，大写字母开头
>
> `type  StringOrNumber = string | number`



 `typeof` 可以获取一个对象接口所有key值

  ```typescript
  interface Foo {
      name: string;
      age: number
  }
  type T = typeof Foo // -> 'name' | 'age'
  ```

 `in` 可以遍历枚举类型

  ```typescript
  type Keys = 'a' | 'b'
  type Obj = {
      [p in Keys]: any
  }
  // -> { a: any, b: any }
  ```

  

## 理解一些工具泛型的使用方法

| 名称        | 源码                                                         | 举例说明                                                     | 作用                                      |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------- |
| Record      | type Record<K extends keyof any, T> = { [P in K]: T };       | type T11 = Record<'a' \| 'b' \| 'c', Person>;<br /> // { a: Person; b: Person; c: Person; } |                                           |
| Partial     | type Partial<T> = {  [P in keyof T]?: T[P]; };               | 只能用于一层                                                 | 让必选参数变成可选参数                    |
| Required    | type Required<T> = {  [P in keyof T]-?: T[P]; };             |                                                              | 让可选参数变成必选参数                    |
| Pick        | type Pick<T, K extends keyof T> = {     [P in K]: T[P]; };   | type NewPerson = Pick<Person, 'name'>; // { name: string; }  | 只选接口中的部分属性                      |
| Exclude     |                                                              |                                                              |                                           |
| ReturnType  |                                                              |                                                              | 获取方法的返回值类型                      |
| ThisType    | interface ThisType<T> { }                                    |                                                              | 是用于指定上下文对象类型的。              |
| NonNullable | type NonNullable<T> = T extends null \| undefined ? never : T; | type T22 = '123' \| '222' \| null; <br />type T23 = NonNullable<T22>; // '123' \| '222' | 用来过滤类型中的 null 及 undefined 类型。 |



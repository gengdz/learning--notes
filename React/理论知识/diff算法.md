# diff 算法

它的签名应该是这样的: `IVNode -> IVNode -> DOM 操作`

## 设计动机
两棵树对比差异拿到最小操作数的时间复杂度为 O(n<sup>3</sup>)，其中 n 为树中元素的个数

这个代码太大。为了解决这个问题，React 提出了一套 O(n) 的 *启发式算法*
1. 两个不同类型的元素会产生不同的树
2. 开发者可以通过 key 来暗示哪些子元素在不同的渲染下能保持稳定





## 比较的过程
* **Tree diff**
将新旧两颗树逐层进行对比，找出哪些节点需要更新
如果节点是组件，就看 Component diff
如果节点是标签，就看 Element diff
* **Component diff**
如果节点是组件，就先看组件类型
类型不同直接替换（删除旧的）
类型相同则只更新属性
然后深入组件做 Tree diff（递归）
* **Element diff**
如果节点是原生标签，则看标签名
标签名不同直接替换，相同则只更新属性
然后进入标签后做 Tree diff（递归)



## Dom diff 的缺点

* 同级节点对比存在 bug
比如 [1, 2, 3] -> 删除 2 -> [1, 3];
原因是：首先对比 1 和 1，发现 「1 没变」；然后对比 2 和 3，发现「2 变成了 3」；最后对比 3 和 undefined，发现 「3 被删除了」，然后计算机得出的结论是： 「2 变成了 3」以及 「3 被删除了」。
这显然不是我们想看到的，怎么解决？
**加 key**

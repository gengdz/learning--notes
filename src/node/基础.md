## Node.js是什么？

* Node.js® is a JavaScript runtime built on [Chrome's V8 JavaScript engine](https://v8.dev/).
  * Node.js 不是一门语言，不是一个库，不是一个框架
  * Node.js是一个javascript运行时环境，是一个平台
  * 构建于Chrome的 v8引擎之上
  * Node.js能解析和执行javascript代码，以前只有浏览器能执行js代码
* 浏览器中的JavaScript
  *  EcmaScript
  * BOM
  * DOM
* Node.js中的javaSript
  * 	EcmaScript
  * Node.js为JavaScript提供的一些服务器级别的API
    * 	文件读写
    * 	网络服务的构建
    * 	网络通讯
    * 	http服务
    * 	......
* Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient
  * event-driven 事件驱动
  * non-blocking I/O model 非阻塞IO模型（异步）
  * lightweight and efficient 轻量和高效
* Node.js' package ecosystem, npm, is the largest ecosystem of open source libraries in the world.
  * 使用 `npm` 作为包管理器，目前 `npm` 是开源库里包管理最大的生态，功能强大



## Node.js能做什么？

* web服务器后台
* 命令行工具（npm,webpack,git）



## Node.js版hello node

### 代码示例：

```javascript
const welcomeWord = 'hello Node.js'
console.log(welcomeWord)
```

### 执行方法：

`node hello.js`



## Node.js 文件操作

### 读取文件

#### 代码示例：

```javascript
const fs = require('fs')

fs.readFile('../hello.js', ((err, data) => {
  if (err) return console.log('文件读取失败')
  console.log(data.toString())
}))
```

### 写文件

代码示例：

```javascript
const fs = require('fs')

const appendContent = '我通过fs模块向文件中添加内容'
fs.writeFile('./content.md', appendContent, err => {
  if (err) return console.log('文件写入失败')
  console.log(`数据写入成功`)
})
```


## 服务端渲染和客户端渲染

### 服务端渲染的本质：



![1568263617131](C:\Users\dezhougeng\AppData\Roaming\Typora\typora-user-images\1568263617131.png)

![1568264306537](C:\Users\dezhougeng\AppData\Roaming\Typora\typora-user-images\1568264306537.png)

![1568264403886](C:\Users\dezhougeng\AppData\Roaming\Typora\typora-user-images\1568264403886.png)

![1568264886128](C:\Users\dezhougeng\AppData\Roaming\Typora\typora-user-images\1568264886128.png)

## http
### server
#### 代码示例
```javascript
const http = require('http')

const server = http.createServer()

server.on('request', (req, res) => {
    const reqUrl = req.url
    const reqAddress = req.socket.remoteAddress
    const reqPort = req.socket.remotePort
    console.log(`地址是：${reqAddress} ---- ${reqPort}`)
    res.setHeader('Content-Type', 'text/plain;charset=utf-8')
    if (reqUrl === '/login') {
        const result = [
            {
                name: 'gengdz',
                age: 18
            }, {
                name: 'sunpang',
                age: 18
            }
        ]
        res.end(JSON.stringify(result))
    } else if (reqUrl === '/page') {
        res.end('返回的是中文')
    } else {
        res.end('404')
    }
})
server.listen(3000, () => {
    console.log('服务器启动了')
})

// 一般直接在response.end('返回的内容')
// 制定返回的类型 res.setHeader('Content-Type', 'text/plain;charset=utf-8')

```

#### 使用说明：
* 一般直接使用response.end('返回的内容')
* 返回的内容只能是字符串或者二进制流数据
* 不同的资源对应的Content-Type是不一样的
* 图片不需要制定编码
* 一般只为字符数据制定编码

## Node中的模块概念

* Node为JavaScrip提供了很多系统级别的api,这些api大多被封装在一个个具名核心模块内，比如文件操作的`fs`、http服务构建的`http`、`path`路径操作、`os`操作系统模块。
* Node中没有全局作用域的概念，只有模块作用域的概念（文件作用域）。即 a.js中有个变量`const  test = 'a'`，b.js同样有个`const test = 'b'`,然后在a.js中引入b.js ,打印test的值为 ***a***。
* Node中模块有三种
  * Node提供的具名核心模块
  * 用户自定义的模块
    * require	-> 
    * exports   -> 导出的默认值为{}，空对象
  * 第三方模块

## IP地址和端口号的概念

每个计算机只有一个物理网卡，如果没有端口的话，qq、微信等都发送到这里，没办法区别和管理。

现在有了端口的概念，那么qq的消息只发送到网卡的2000端口，微信的只发送到2222端口，这样就识别开来了

* IP地址用来定位计算机
* 端口号用来定义具体的应用程序
* (所有需要联网通讯的软件，必须要有端口号)
* 端口号的范围是 0-65536



## 模板引擎的使用

1. 安装 yarn add art-template 

2. 引擎的使用

   ```javascript
   const htmlContent = template.render(string, {
           comments
         })
   
   // 说明：第一个参数为string类型的要渲染的值，
   // 第二个参数为一个对象。为要替换模板中的那些值
   ```

     ```html
       <ul class="list-group">
         {{each comments}}
         <li class="list-group-item">
           {{ $value.name }}说：{{ $value.message }}
           <span class="pull-right">{{ $value.dateTime }}</span>
         </li>
         {{/each}}
     </ul>
     ```



## 浏览器发送多次请求的原因

浏览器收到HTML相应内容之后，就从前往后解析。

当遇到 link、img、vedio、audio、script、iframe 等等带有src或者herf (link)属性标签(具有外链的资源)的时候
浏览器会自动对这些资源发起新的请求

## 处理网站中的静态资源

* 默认把静态资源放在public文件中，访问的url就是文件的位置



## 留言板的示例

代买示例：

```javascript
const http = require('http')
const fs = require('fs')
const template = require('art-template')
const url = require('url')


const comments = [
  {
    name: '耿德洲',
    message: '耿德洲发表了帖子',
    dateTime: '2019/9/12'
  },
]

http.createServer((req, res) => {

  const pathObj = url.parse(req.url, true)
  const pathname = pathObj.pathname
  if (pathname === '/') {
    fs.readFile('./views/index.html', (err, data) => {
      if (err) return res.end('notFoundPage')
      const htmlContent = template.render(data.toString(), {
        comments
      })
      res.end(htmlContent)
    })
  } else if (pathname.indexOf('/public/') === 0) {
    fs.readFile('.' + pathname, (err, data) => {
      if (err) return res.end('notFoundPage')
      res.end(data)
    })
  } else if (pathname === '/post') {
    fs.readFile('./views/post.html', (err, data) => {
      if (err) return res.end('notFoundPage')
      res.end(data)
    })
  } else if (pathname === '/pinglun') {
    const comment = pathObj.query
    comment.dateTime = new Date()
    comments.unshift(comment)
                      
    res.statusCode = 302
    res.setHeader('Location', '/')
    res.end()

  } else {
    fs.readFile('./views/404.html', (err, data) => {
      return res.end(data)
    })
  }

})
  .listen(3000, () => {
    console.log('runnning')
  })
```

### 细节说明：

> ***url模块的使用方法*** 
>
> `const pathObj = url.parse(req.url, true)` ---> 拿到path对象
>
> `const pathname = pathObj.pathname` ---> pathname 请求的地址
>
> `const params = pathObj.query `   --> query 请求的参数
>
> 
>
> ***如何通过服务器让客户端重定向？***
>
> 状态码设置为302，临时重定向 `res.statusCode = 302`
> 在相应头中通过Location告诉客户端往哪里重定向 `res.setHeader('Location','/')`



## 模块系统

### 导出多个成员

```javascript
erports.add = (a,b) => a + b
exports.name = 'gdz'

const exportResult = require('./test')
// 使用方式
exportResult.add(1,3)
```

### 导出单个成员

```javascript
const add = (a,b) => a + b
module.exports = add
```


## Node.js是什么？

* Node.js® is a JavaScript runtime built on [Chrome's V8 JavaScript engine](https://v8.dev/).
  * Node.js 不是一门语言，不是一个库，不是一个框架
  * Node.js是一个javascript运行时环境，是一个平台
  * 构建于Chrome的 v8引擎之上
  * Node.js能解析和执行javascript代码，以前只有浏览器能执行js代码
* 浏览器中的JavaScript
  *  EcmaScript
  * BOM
  * DOM
* Node.js中的javaSript
  * 	EcmaScript
  * Node.js为JavaScript提供的一些服务器级别的API
    * 	文件读写
    * 	网络服务的构建
    * 	网络通讯
    * 	http服务
    * 	......
* Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient
  * event-driven 事件驱动
  * non-blocking I/O model 非阻塞IO模型（异步）
  * lightweight and efficient 轻量和高效
* Node.js' package ecosystem, npm, is the largest ecosystem of open source libraries in the world.
  * 使用 `npm` 作为包管理器，目前 `npm` 是开源库里包管理最大的生态，功能强大



## Node.js能做什么？

* web服务器后台
* 命令行工具（npm,webpack,git）



## Node.js版hello node

### 代码示例：

```javascript
const welcomeWord = 'hello Node.js'
console.log(welcomeWord)
```

### 执行方法：

`node hello.js`



## Node.js 文件操作

### 读取文件

#### 代码示例：

```javascript
const fs = require('fs')

fs.readFile('../hello.js', ((err, data) => {
  if (err) return console.log('文件读取失败')
  console.log(data.toString())
}))
```

### 写文件

代码示例：

```javascript
const fs = require('fs')

const appendContent = '我通过fs模块向文件中添加内容'
fs.writeFile('./content.md', appendContent, err => {
  if (err) return console.log('文件写入失败')
  console.log(`数据写入成功`)
})
```


## 服务端渲染和客户端渲染

### 服务端渲染的本质：



![1568263617131](C:\Users\dezhougeng\AppData\Roaming\Typora\typora-user-images\1568263617131.png)

![1568264306537](C:\Users\dezhougeng\AppData\Roaming\Typora\typora-user-images\1568264306537.png)

![1568264403886](C:\Users\dezhougeng\AppData\Roaming\Typora\typora-user-images\1568264403886.png)

![1568264886128](C:\Users\dezhougeng\AppData\Roaming\Typora\typora-user-images\1568264886128.png)

## http
### server
#### 代码示例
```javascript
const http = require('http')

const server = http.createServer()

server.on('request', (req, res) => {
    const reqUrl = req.url
    const reqAddress = req.socket.remoteAddress
    const reqPort = req.socket.remotePort
    console.log(`地址是：${reqAddress} ---- ${reqPort}`)
    res.setHeader('Content-Type', 'text/plain;charset=utf-8')
    if (reqUrl === '/login') {
        const result = [
            {
                name: 'gengdz',
                age: 18
            }, {
                name: 'sunpang',
                age: 18
            }
        ]
        res.end(JSON.stringify(result))
    } else if (reqUrl === '/page') {
        res.end('返回的是中文')
    } else {
        res.end('404')
    }
})
server.listen(3000, () => {
    console.log('服务器启动了')
})

// 一般直接在response.end('返回的内容')
// 制定返回的类型 res.setHeader('Content-Type', 'text/plain;charset=utf-8')

```

#### 使用说明：
* 一般直接使用response.end('返回的内容')
* 返回的内容只能是字符串或者二进制流数据
* 不同的资源对应的Content-Type是不一样的
* 图片不需要制定编码
* 一般只为字符数据制定编码

## Node中的模块概念

* Node为JavaScrip提供了很多系统级别的api,这些api大多被封装在一个个具名核心模块内，比如文件操作的`fs`、http服务构建的`http`、`path`路径操作、`os`操作系统模块。
* Node中没有全局作用域的概念，只有模块作用域的概念（文件作用域）。即 a.js中有个变量`const  test = 'a'`，b.js同样有个`const test = 'b'`,然后在a.js中引入b.js ,打印test的值为 ***a***。
* Node中模块有三种
  * Node提供的具名核心模块
  * 用户自定义的模块
    * require	-> 
    * exports   -> 导出的默认值为{}，空对象
  * 第三方模块

## IP地址和端口号的概念

每个计算机只有一个物理网卡，如果没有端口的话，qq、微信等都发送到这里，没办法区别和管理。

现在有了端口的概念，那么qq的消息只发送到网卡的2000端口，微信的只发送到2222端口，这样就识别开来了

* IP地址用来定位计算机
* 端口号用来定义具体的应用程序
* (所有需要联网通讯的软件，必须要有端口号)
* 端口号的范围是 0-65536



## 模板引擎的使用

1. 安装 yarn add art-template 

2. 引擎的使用

   ```javascript
   const htmlContent = template.render(string, {
           comments
         })
   
   // 说明：第一个参数为string类型的要渲染的值，
   // 第二个参数为一个对象。为要替换模板中的那些值
   ```
   ```html
   <ul class="list-group">
     {{each comments}}
     <li class="list-group-item">
       {{ $value.name }}说：{{ $value.message }}
       <span class="pull-right">{{ $value.dateTime }}</span>
     </li>
     {{/each}}
   </ul>
   ```
   
   
## 浏览器发送多次请求的原因

浏览器收到HTML相应内容之后，就从前往后解析。

当遇到 link、img、vedio、audio、script、iframe 等等带有src或者herf (link)属性标签(具有外链的资源)的时候
浏览器会自动对这些资源发起新的请求

## 处理网站中的静态资源

* 默认把静态资源放在public文件中，访问的url就是文件的位置



## 留言板的示例

第一版示例：

```javascript
const http = require('http')
const fs = require('fs')
const template = require('art-template')
const url = require('url')


const comments = [
  {
    name: '耿德洲',
    message: '耿德洲发表了帖子',
    dateTime: '2019/9/12'
  },
]

http.createServer((req, res) => {

  const pathObj = url.parse(req.url, true)
  const pathname = pathObj.pathname
  if (pathname === '/') {
    fs.readFile('./views/index.html', (err, data) => {
      if (err) return res.end('notFoundPage')
      const htmlContent = template.render(data.toString(), {
        comments
      })
      res.end(htmlContent)
    })
  } else if (pathname.indexOf('/public/') === 0) {
    fs.readFile('.' + pathname, (err, data) => {
      if (err) return res.end('notFoundPage')
      res.end(data)
    })
  } else if (pathname === '/post') {
    fs.readFile('./views/post.html', (err, data) => {
      if (err) return res.end('notFoundPage')
      res.end(data)
    })
  } else if (pathname === '/pinglun') {
    const comment = pathObj.query
    comment.dateTime = new Date()
    comments.unshift(comment)
                      
    res.statusCode = 302
    res.setHeader('Location', '/')
    res.end()

  } else {
    fs.readFile('./views/404.html', (err, data) => {
      return res.end(data)
    })
  }

})
  .listen(3000, () => {
    console.log('runnning')
  })
```

### 细节说明：

> ***url模块的使用方法*** 
>
> `const pathObj = url.parse(req.url, true)` ---> 拿到path对象
>
> `const pathname = pathObj.pathname` ---> pathname 请求的地址
>
> `const params = pathObj.query `   --> query 请求的参数
>
> 
>
> ***如何通过服务器让客户端重定向？***
>
> 状态码设置为302，临时重定向 `res.statusCode = 302` （301为永久重定向）
> 在相应头中通过Location告诉客户端往哪里重定向 `res.setHeader('Location','/')`



## 模块系统

### 导出多个成员

```javascript
// 导出多个成员的第一种方式
erports.add = (a,b) => a + b
exports.name = 'gdz'

// 导出多个成员的第二种方式
module.exports = {
  add:(a,b) => a + b,
  name: 'gdz'
} 

// 使用方式
const exportResult = require('./test')
exportResult.add(1,3)
```

### 导出单个成员

```javascript
const add = (a,b) => a + b
module.exports = add
```

### 细节说明

> module.exports === exports



## node优先会从缓存中加载

## package.json文件说明

### 作用

package.json是包管理文件，里面是对项目的描述（产品说明书），创建方式：`npm init`，构成主要是：

| 属性         | 说明                   | 命令               |
| ------------ | ---------------------- | ------------------ |
| main         | 项目的入口             |                    |
| dependencies | 依赖，生产和开发都需要 | npm i react --save |
|              |                        |                    |
|              |                        |                    |

### 细节说明

> * `npm i --global react`  --> 全局安装一个包



## npm 常用命令

| 命令                                                    | 说明                             |
| ------------------------------------------------------- | -------------------------------- |
| npm init  (npm init -y)                                 | 生成一个package.json (跳过向导)  |
| npm i react --save                                      | 安装包，并加入到dependencies中   |
| npm uninstall react --save                              | 删除包，并且同时删除这个包的依赖 |
| npm 命令 --help                                         | 查看某个命令的帮助说明           |
| npm config set registry https://registry.npm.taobao.org | 使用淘宝镜像                     |
| npm config list                                         | 查看npm配置信息                  |

说明：

> * 在npm5之后，npm install react.js 不加--save 也可以保存依赖信息
> * `package-lock.json`会保存所有依赖包的信息(版本，下载地址)
>   * 这样在`npm install`的时候速度就会提升
>   * npm会对版本进行锁定。

## Express

### 是什么？

express 是一个web框架,封装了nodejs中的http模块，加快开发效率，补充了原生nodejs的不足

### 怎么用？

```javascript
const express = require('express')

const app = express()

app.get('/login',(req,res) => {
  res.send('hello express')
})

app.use('/public/',express.static('./public/'))

app.listen(3000,(req,res) => {
  console.log('启动在了3000端口')
})
```

说明：

* 通过res.send发送数据

### express中获取数据

* get请求
  * req.query
* post请求
  * 借助 body-parser中间件，然后 req.boby

### express middleware的使用

* body-parser 用来解析post请求中的body参数

  ```javascript
  // 配置body-parser 中间件
  app.use(bodyParser.urlencoded({extended:false}))
  app.use(bodyParser.json())
  ```

  

### express-art-template的使用方法和说明

```javascript
// 设置为.html结尾文件，默认是.art结尾
app.engine('html', require('express-art-template'));
// 设置views视图渲染存储目录，默认读取views文件夹下面的文件
app.set('views', path.join(__dirname, 'views'));
```

### 留言板express版示例

```javascript
const express = require('express')
const bodyParser = require('body-parser')

const app = express()

const comments = [
    {
        name: '耿德洲',
        message: '耿德洲发表了帖子',
        dateTime: '2019/9/12'
    },
]

// 配置express-art-template
app.engine('html', require('express-art-template'));

// 配置body-parser 中间件
app.use(bodyParser.urlencoded({extended:false}))
app.use(bodyParser.json())

app.get('/', (req, res) => {
    res.render('index.html', {
        comments
    })
})

app.get('/post', (req, res) => {
   res.render('post.html')
})

app.post('/post', (req, res) => {
    const comment = req.body
    comment.dateTime = Date.now()
    comments.unshift(comment)
    res.redirect('/')
})

// 1.开放静态资源,推荐这种方式
app.use('/public/', express.static('./public/'))

app.listen(3000, () => {
    console.log('服务启动在了3000端口')
})
```





### 修改完代码自动重启的工具

可以使用一个叫`nodemon`的第三方工具，实现修改代码之后服务器自动重启的功能，
可以通过 `yarn global add nodemon`进行全局安装
使用方式 现在使用 `nodemon app.js`的方式启动

## 路由的基本理解

路由就是一张表，里面有具体的映射关系
(请求类型 + 路径)	-->  请求处理函数

* post类型的  /login   --> handlePostLogin()
* get类型的   /login  --> handleGetLogin()
* /post   --> handlePost()

## 文件存储版的crud

```javascript
/**
 * app.js 是入口文件
 * 职责是：
 *  创建服务
 *  做一些服务相关配置
 *    模板引擎
 *    bodyParser解析表单body
 *    提供静态资源服务
 *  挂载路由
 *  监听端口，启动服务
 */
const express = require('express')
const bodyParser = require('body-parser')
const router = require('./router')

const app = express()
app.engine('html', require('express-art-template'));
app.use(bodyParser.urlencoded({ extended: false }))
app.use(bodyParser.json())

app.use('/public/', express.static('./public/'))
// 挂载路由
app.use(router)

app.listen(3000, () => {
  console.log('crud-exprss版启动在3000端口')
})
```

```javascript
/**
 * route.js职责是：
 *  进行路由分发
 *    （请求类型+url地址） --> 转到相应的处理函数
 */
const express = require('express')
const studentServer = require('./studentServer')

const router = express.Router()

router.get('/list', (req, res) => {
  studentServer.find((err, students) => {
    if (err) return res.status(500).send('服务器异常')
    res.render('index.html', { students })
  })
})

// 新增学生
router.post('/students/new', (req, res) => {
  studentServer.add((err) => {
    if (err) return res.status(500).send('服务器异常')
    res.redirect('/list')
  }, req.body)
})

// 编辑初始化
router.get('/students/edit', (req, res) => {
  studentServer.findById((err, student) => {
    if (err) return res.status(500).send('服务器异常')
    res.render('edit.html', { student })
  }, parseInt(req.query.id))

})

// 更新学生
router.post('/students/edit', (req, res) => {
  studentServer.editById(err => {
    if (err) return res.status(500).send('服务器异常')
    res.redirect('/list')
  }, req.body)
})

// 删除学生
router.get('/students/delete', (req, res) => {
  studentServer.delete(err => {
    if (err) return res.status(500).send('服务器异常')
    res.redirect('/list')
  }, req.query.id)
})

// 新增的html页面
router.get('/students/new', (req, res) => {
  res.render('new.html')
})

module.exports = router

```

```javascript
/**
 * server层的职责是：操作文件中数据，只处理数据，不关心业务
 * 也就是说：只有一些函数，给入参，返回结果
 */

const fs = require('fs')
const dbPath = './db.json'

// 获取学生列表
exports.find = (callback) => {
  fs.readFile(dbPath, 'utf8', (err, data) => {
    if (err) return callback(err)
    callback(null, JSON.parse(data).students)
  })
}

// 根据id查学生
exports.findById = (callback, id) => {
  fs.readFile(dbPath, 'utf8', (err, data) => {
    if (err) return callback(err)

    const students = JSON.parse(data).students
    const student = students.find(item => item.id === parseInt(id))
    callback(null, student)
  })
}

// 添加学生
exports.add = (callback, student) => {
  fs.readFile(dbPath, 'utf8', (err, data) => {
    if (err) return callback(err)

    const students = JSON.parse(data).students
    student.id = students[students.length - 1].id + 1
    students.push(student)

    const fileData = JSON.stringify({ students })
    fs.writeFile(dbPath, fileData, err => {
      if (err) return callback(err)
      callback(null)
    })
  })
}

// 更新学生信息
exports.editById = (callback, student) => {
  fs.readFile(dbPath, 'utf8', (err, data) => {
    if (err) return callback(err)

    const students = JSON.parse(data).students
    student.id = parseInt(student.id)
    const oldStudent = students.find(item => item.id === student.id)
    for (let key in student) {
      oldStudent[key] = student[key]
    }
    const fileData = JSON.stringify({ students })
    fs.writeFile(dbPath, fileData, err => {
      if (err) return callback(err)
      callback(null)
    })
  })

}

// 删除学生
exports.delete = (callback, id) => {
  fs.readFile(dbPath, 'utf8', (err, data) => {
    if (err) return callback(err)

    const students = JSON.parse(data).students
    const deleteIndex = students.findIndex(item => item.id === parseInt(id))
    students.splice(deleteIndex, 1)

    const fileData = JSON.stringify({ students })
    fs.writeFile(dbPath, fileData, err => {
      if (err) return callback(err)
      callback(null)
    })
  })

}
```



## 回调函数(callback)

### 什么时候使用？

* 在异步编程中使用
* 如果需要得到一个函数内部异步操作的结果，这时候必须要使用回调函数

### 如何使用？

* 在调用的位置传递一个函数进去
* 在封装的函数内部调用传递过来的函数



## MongoDB介绍和使用

### 说明
NoSql 非关系型数据库，MongoDB是长得最像关系型数据库的非关系型数据库

名词对比：

| 关系型数据库 | MongoDB                |
| ------------ | ---------------------- |
| 数据库       | 数据库                 |
| 数据表       | 集合<数组>(collection) |
| 表记录       | 文档对象               |

MongoDB不需要设计表结构，可以任意往里面存数据，没有结构性这一说

MongoDB的数据结构大致如下：

```javascript
{
  qq:{
       users:[
         {
            name:'张三'，
            age:18
          }                                                           
        ],
       products:[
                                                                        
       ]
  },
                      
  baidu:{
                      
  },
                      
  taobao:{
                      
  }
  
}
```



### 启动和关闭数据库

启动
```shell
# mongodb 默认使用执行mongod 命令所在的盘符根目录下的/data/db 作为自己的数据存储目录
# 所以在第一次执行该命令之前需要手动新建/data/db
mongod
```

如果想修改默认的存储路径可以使用：

```shell
mongod --dppath=数据存储目录
```

停止

```
在开启服务的控制台，直接ctrl+c 即可
```

### 连接和退出数据库

连接

```shell
# 该命令默认连接本机的服务
mongo
```

退出

```shell
# 在连接状态，输入exit退出连接
exit
```

### 常用命令

| 命令                                  | 说明                             |
| ------------------------------------- | -------------------------------- |
| show dbs                              | 查看显示所有数据库               |
| db                                    | 显示当前操作的数据库             |
| use 数据库名称                        | 切换 / 新建后切换 到指定的数据库 |
| db.students.insertOne({"name":"gdz"}) | 在students集合中插入一条数据     |
| show collections                      | 显示当前db的所有集合             |
| db.students.find()                    | 显示students集合的所有数据       |
|                                       |                                  |
|                                       |                                  |
|                                       |                                  |

说明：

* 如果当前数据库没数据，则show dbs不显示这个数据库
* 默认在test数据库(系统创建的)

## 使用mongoose在node中操作mongodb

使用mongoose来操作MongoDB，他是基于mongodb做的再一次封装

### 建立集合四部曲

```javascript
const mongoose = require('mongoose')

// 1.连接数据库
mongoose.connect('mongodb://localhost/students', { useNewUrlParser: true, useUnifiedTopology: true }, err => {
  if (err) return console.log('Connection Error:' + err)
  console.log('Connection success!')
})

// 2.设计文档结构
const userSchema = new mongoose.Schema({
  userName: {
    type: String,
    required: true,
  },
  age: {
    type: Number,
    required: true,
  },
  alias: String,
})

// 3.将文档结构发布为模型
// 第一个参数：传入一个大写的字符串表示你的数据库名称，MongoDB会自动转成小写的复数形式
//            例如： User --> users
// 第二个参数：架构 Schema
// 返回值：模型构造函数
const User = mongoose.model('User', userSchema)

// 4.使用模型构造函数，对集合中的数据进行操作
```

### 增加数据

```javascript
const gdz = new User({
  userName: '张三',
  age: 18,
  alias: '耿德洲'
})
gdz.save((err, result) => {
  if (err) return console.log('保存失败')
  console.log(result)
})
```

### 查询数据

```javascript
// 查询所有
User.find((err, res) => {
  if (err) return console.log('查询失败')
  console.log(res)
})

// 条件查询 --> []
User.find({userName: '张三'},(err,data) => {
  if(err) return console.log('查询出错')
  console.log(data)
})

// 条件查询一个 --> {}
User.findOne({userName:'张三'},(err,data) => {
  if(err) return console.log('查询出错')
  console.log(data)
})
```

### 删除数据

```javascript
// 删除多个
User.deleteMany({ userName: 'gdz' }, (err, data) => {
  if (err) return console.log('删除出错')
  console.log(data)
})
// 删除一个
User.deleteOne({ userName: 'gdz' }, (err, data) => {
  if (err) return console.log('删除出错')
  console.log(data)
})
```

### 更新数据

```javascript
// 更新一个
User.updateOne({ userName: '张三' }, { alias: '张狗蛋' }, (err, data) => {
  if (err) return console.log('更新失败')
  console.log(data)
})

// 更新多个
User.updateMany({ userName: '张三' }, { alias: '张狗蛋' }, (err, data) => {
  if (err) return console.log('更新失败')
  console.log(data)
})
```







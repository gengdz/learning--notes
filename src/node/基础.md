## Node.js是什么？

* Node.js® is a JavaScript runtime built on [Chrome's V8 JavaScript engine](https://v8.dev/).
  * Node.js 不是一门语言，不是一个库，不是一个框架
  * Node.js是一个javascript运行时环境，是一个平台
  * 构建于Chrome的 v8引擎之上
  * Node.js能解析和执行javascript代码，以前只有浏览器能执行js代码
* 浏览器中的JavaScript
  *  EcmaScript
  * BOM
  * DOM
* Node.js中的javaSript
  * 	EcmaScript
  * Node.js为JavaScript提供的一些服务器级别的API
    * 	文件读写
    * 	网络服务的构建
    * 	网络通讯
    * 	http服务
    * 	......
* Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient
  * event-driven 事件驱动
  *  non-blocking I/O model 非阻塞IO模型（异步）
  * lightweight and efficient 轻量和高效
* Node.js' package ecosystem, npm, is the largest ecosystem of open source libraries in the world.
  * 使用 `npm` 作为包管理器，目前 `npm` 是开源库里包管理最大的生态，功能强大



## Node.js能做什么？

* web服务器后台
* 命令行工具（npm,webpack,git）



## Node.js版hello node

### 代码示例：

```javascript
const welcomeWord = 'hello Node.js'
console.log(welcomeWord)
```

### 执行方法：

`node hello.js`



## Node.js 文件操作

### 读取文件

#### 代码示例：

```javascript
const fs = require('fs')

fs.readFile('../hello.js', ((err, data) => {
  if (err) return console.log('文件读取失败')
  console.log(data.toString())
}))
```

### 写文件

代码示例：

```javascript
const fs = require('fs')

const appendContent = '我通过fs模块向文件中添加内容'
fs.writeFile('./content.md', appendContent, err => {
  if (err) return console.log('文件写入失败')
  console.log(`数据写入成功`)
})
```


## 服务端渲染和客户端渲染

### 服务端渲染的本质：



![1568263617131](C:\Users\dezhougeng\AppData\Roaming\Typora\typora-user-images\1568263617131.png)

![1568264306537](C:\Users\dezhougeng\AppData\Roaming\Typora\typora-user-images\1568264306537.png)

![1568264403886](C:\Users\dezhougeng\AppData\Roaming\Typora\typora-user-images\1568264403886.png)

![1568264886128](C:\Users\dezhougeng\AppData\Roaming\Typora\typora-user-images\1568264886128.png)

## http
### server
#### 代码示例
```javascript
const http = require('http')

const server = http.createServer()

server.on('request', (req, res) => {
    const reqUrl = req.url
    const reqAddress = req.socket.remoteAddress
    const reqPort = req.socket.remotePort
    console.log(`地址是：${reqAddress} ---- ${reqPort}`)
    res.setHeader('Content-Type', 'text/plain;charset=utf-8')
    if (reqUrl === '/login') {
        const result = [
            {
                name: 'gengdz',
                age: 18
            }, {
                name: 'sunpang',
                age: 18
            }
        ]
        res.end(JSON.stringify(result))
    } else if (reqUrl === '/page') {
        res.end('返回的是中文')
    } else {
        res.end('404')
    }
})
server.listen(3000, () => {
    console.log('服务器启动了')
})

// 一般直接在response.end('返回的内容')
// 制定返回的类型 res.setHeader('Content-Type', 'text/plain;charset=utf-8')

```

#### 使用说明：
* 一般直接使用response.end('返回的内容')
* 返回的内容只能是字符串或者二进制流数据
* 不同的资源对应的Content-Type是不一样的
* 图片不需要制定编码
* 一般只为字符数据制定编码

## Node中的模块概念

* Node为JavaScrip提供了很多系统级别的api,这些api大多被封装在一个个具名核心模块内，比如文件操作的`fs`、http服务构建的`http`、`path`路径操作、`os`操作系统模块。
* Node中没有全局作用域的概念，只有模块作用域的概念（文件作用域）。即 a.js中有个变量`const  test = 'a'`，b.js同样有个`const test = 'b'`,然后在a.js中引入b.js ,打印test的值为 ***a***。
* Node中模块有三种
  * Node提供的具名核心模块
  * 用户自定义的模块
    * require	-> 
    * exports   -> 导出的默认值为{}，空对象
  * 第三方模块

## IP地址和端口号的概念

每个计算机只有一个物理网卡，如果没有端口的话，qq、微信等都发送到这里，没办法区别和管理。

现在有了端口的概念，那么qq的消息只发送到网卡的2000端口，微信的只发送到2222端口，这样就识别开来了

* IP地址用来定位计算机
* 端口号用来定义具体的应用程序
* (所有需要联网通讯的软件，必须要有端口号)
* 端口号的范围是 0-65536


# webpack基础？
## 是什么？
> webpack是一个模块打包机，它的任务是：分析项目结构，找到js模块，以及其它一些浏览器不能直接运行的拓展语言(如less,ts)，并将其打包成合适的格式，供浏览器使用。

## 能干什么？

* 代码转换  -- 将es6转换成es5,将less装换成css等
* 文件优化  -- 可以压缩文件大小
* 代码校验  -- eslint
* 自动刷新
* 代码分割
* 模块合并
* 自动发布

## 安装

1. yarn init 创建或者更新一个package.json 文件   yarn init -y 跳过交互式的创建
2. yarn add webpack webpack-cli -D 安装之后会生成node_modules模块， -D表示是开发使用，生产不需要。

## 使用
* 使用npx webpack 进行打包 默认打包的出口是dist/main.js
* 新建一个webpack.config.js 对webpack进行配置

## 核心概念

* entry
* output
* loader   -- webpack自身只能处理js模块，使用不同的loader可以将不同类型的文件转成webpack可以处理的模块然后就可以进行打包操作了。其中loader的test属性表明：配置哪些文件，use属性代表使用哪些loader。
* plugins


## 重要配置项介绍
| 配置名    | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| entry     | webpack执行构建的入口                                        |
| output    | 构建的输出结果                                               |
| module    | webpack中一切皆模块，一个模块对应着一个文件。<br />webpack从entry入口开始递归找出所有依赖的模块 |
| plugins   | 扩展插件，<br />在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果，或者做你想做的事情 |
| devServer | 开发服务器配置，作用是只是在内存中打包，<br />并可以采用localhost的打开 |

### 单页面配置

```javascript
entry: './src/index.js',   // 入口  
output: {
    filename: 'index.js',    // 打包后的文件名, 可以加上hash 如： index[hash:8].js
    path: path.resolve(__dirname, 'dist'), // 打包后的地址，这里必须是一个绝对路径
  },

  optimization: { // 只有在生产模式下才能压缩
    minimizer: [new TerserJSPlugin({}), new OptimizeCSSAssetsPlugin({})],
  },

  plugins: [   // 插件数组，
    new HtmlWebpackPlugin({
      template: './src/index.html', // 生成的模板
      filename: 'index.html', // 打包之后的文件名
      minify: { // 压缩设置
        removeAttributeQuotes: true, //去掉双引号
        collapseWhitespace: true, // 压缩空格
      },
      hash: true, // shengcheng hash值
    }),
  ],
```

### 多页配置

```javascript
entry: {
   home:'./src/index.js',
   company:'./src/other.js',
  },
output:{
    filename:[name].js,
    path: path.resolve(__dirname, 'dist'),
}
      
plugins:[
    new HtmlWebpackPlugin({
      template: './src/index.html', // 生成的模板
      filename: 'home.html', // 打包之后的文件名
      chunks: ["home"],
    }),
     new HtmlWebpackPlugin({
      template: './src/index.html', // 生成的模板
      filename: 'company.html', // 打包之后的文件名
      chunks: ["home","other"],
    }),
]
```

### devtool <调试工具>

souce-map: 源码映射,方便出错调试

| 配置名称                                  | 效果                                                 |
| ----------------------------------------- | ---------------------------------------------------- |
| `devtool: 'source-map'`                   | 会单独生成一个 sourcemap文件<br />出错了会标识行和列 |
| `devtool: 'eval-source-map'`              | 不产生单独的sourcemap<br />出错了会标识行和列        |
| `devtool: 'cheap-moudle-source-map'`      | 会生成映射文件<br />不会标识列                       |
| `devtool: 'cheap-moudle-eval-source-map'` | 不会生成映射文件<br />不会标识列                     |

### 实时打包

```javascript
watch:true;
watchOptions:{
    poll: 1000,
    aggregateTimeout:500, // 防抖时间间隔
    ignored：/node_modules/
}

```

### 几个插件

* 清空dist之后再打包

  ```javascript
  const { CleanWebpackPlugin } = require('clean-webpack-plugin');
  plugins:[
      new CleanWebpackPlugin()
  ]
  ```

* 把文件拷贝到dist文件

  ```javascript
   new CopyWebpackPlugin([
     {from: 'public',to:'./'}  
   ]),
  ```
  
* 版权插件

  ```javascript
  new webpack.BannerPlugin('耿德洲,2019-09-03')
  ```

### 代理 proxy

1. 服务器接口是3000，webpack中devServer的默认端口是8080

   ```javascript
    proxy:{
         '/api':{
           target: 'http://localhost:3000',
           pathRewrite:{'/api':''}
         }
       }
   ```

2. 前端单纯的模拟数据

   ```javascript
   devServer:{
       before(app){
           app.get('/user', (req, res) => {
               res.json({ name: '耿德洲' })，
           })
       }
   }
   ```

3. 在服务端启动webpack,后端前端公用一个接口

   ```javascript
   
    在服务端启动webpack，
    const middleware = require('webpack-dev-middleware')
   
    const webpack = require('webpack')
   
    const config = require('./webpack.config.js')
   
    const compiler = webpack(config)
   
    app.use(middleware(compiler))
   ```


### resolve配置

```javascript
  // 解析
  resolve: {
    modules: [path.resolve('node_modules')], // 在哪些模块解析
    extensions: ['.js', 'jsx', '.css', '.json'], // 拓展，.js找不到，就找jsx。等等
    // mainFields: ['style','main'],
    // mainFiles: [],
    alias: {  // 别名
      bootstrap: 'bootstrap/dist/css/bootstrap.css',
    }
  },
```



### 动态链接库

原因：第三库没必要每次都打包，因为没有发生变动，打包起来很慢

原理是：将第三方库提前打包成文件，然后在DllReferencePlugin中引用

用到两个webpack自带插件,一个是webpack.DllPlugin，另一个是webpack.DllReferencePlugin



### webpack自带优化
* import多个时，会进行 tree-shaking  会把没用到的代码自动删除掉。但require不会进行tree-shaking
* webpack会自动省略可以简化的代码
* es6模块会把结果放在default上



![1567573240387](C:\Users\dezhougeng\AppData\Roaming\Typora\typora-user-images\1567573240387.png)

### 抽离公共代码

有文件被多个地方使用，如Pateo系列组件，那么可以进行的抽离公共代码

```javascript
  optimization: {  // 优化
      splitChunks: {  // 分割代码块 代替之前的 commonChunkPlugins
          cacheGroups: { // 缓存组
              vendor: { // 第三方模块抽离
                  test: /node_modules/,
                  chunks: 'initial',
                  minSize: 0,
                  minChunks: 2
              },
              common: { // 公共模块
                  chunks: 'initial',
                  minSize: 0,
                  minchunks: 2
                  // priotity: 1,
              },
          }
      }
  },
```

### 懒加载
```javascript
// 这里的import要使用到 在use.options.plugins中配置@babel/plugin-syntax-dynamic-import 
handleClick = () => {
  import(aa.js).then(data=>{
    console.log(data)
  })
}

```




​			